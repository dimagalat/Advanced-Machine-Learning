'''
Created on Aug 26, 2014

@author: manabchetia

This script implements BRUTE FORCE in a BINARY TREE
'''

import itertools as it
import numpy     as np
import time      as t


def createTree(n):
    '''This function creates a dictionary where keys represent the indices of the nodes in the tree and 
    value represents the values that node can take i.e. 0 or 1 
    @param n : number of nodes
    @return  : dictionary. E.g. tree = {node1:0, ..., nodeN:0}  
    '''
    tree = {x+1: 0 for x in xrange(n)}
    return tree


def getTransitionProb(i, j):
    '''This function calculates the transition probability p(Xi|Xj)
    @param  i: Xi
    @param  j: Xj
    @return  : p(Xi|Xj)   
    '''
    if (i==j):
        return 0.95
    else:
        return 0.05
    

def assignValuesToGrid(tree, configuration):   
    '''This function assigns each element of a configuration as values to a dictionary where 
    keys represent the index in the tree
    @param tree          : a dictionary where {node1:0, ..., nodeN:0}
    @param configuration : one of the several configurations generated by itertools such as [110]
    @return tree         : a dictionary where {node1:valueOf(node1), ..., nodeN:valueOf(node2)}
    '''     
    for i in tree.iterkeys():
        tree[i]=configuration[i-1]
    return tree


def getJointProbability(tree):
    '''This function calculates the joint probability for a particular configuration
    @param tree: a dictionary whose keys are indices of the nodes of a tree and values as values of that node i.e. 0 or 1
    {node1:valueOf(node1), ..., nodeN:valueOf(node2)}
    @return: jointProbability of the input tree
    '''
    jointProbability = 1.0
    for index in tree.iterkeys():
        if   (  index == 1  ):
            if (tree[index] == 1):
                jointProbability *= 0.95
            else:
                jointProbability *= 0.05
        else:
            jointProbability *= getTransitionProb(tree[index], tree[index/2])
    return jointProbability


def getTotalProbability(treeNew, configurations):
    '''NOT REQUIRED
    This function calculates the total Probability as a check that probabilities sum up to 1
    @param treeNew        :  a dictionary whose keys are indices of the nodes of a tree and values as values of that node i.e. 0 or 1
    {node1:valueOf(node1), ..., nodeN:valueOf(node2)}
    @param configurations :  [[00]
                               [01]
                               [10]
                               [11]]
    @return               : Total Probability
    '''
    totalProbability = 0.0
    for configuration in configurations:
        treeNew = assignValuesToGrid(treeNew, configuration)
        jointProbability  = getJointProbability(treeNew)
        totalProbability += jointProbability
    return totalProbability 


def printProbabilities(configurations, tree):
    '''This function prints out the required probabilities as asked
    @param configurations : array of all possible configurations
    @param tree           : dictionary. E.g. tree = {node1:0, ..., nodeN:0}    
    '''
    prob1 = 0.0
    prob2 = 0.0
    prob3 = 0.0
    prob4 = 0.0
    
    probx12_1            = 0.0
    probx12_1_x7_1       = 0.0
    probx12_1_x7_1_x15_0 = 0.0
    
    for configuration in configurations:
        treeNew = assignValuesToGrid(tree, configuration)
        if (treeNew[8] == 1):
            prob1 += getJointProbability(treeNew)
        if (treeNew[8] == 1 and treeNew[12] == 1):
            prob2 += getJointProbability(treeNew)
        if (treeNew[8] == 1 and treeNew[12] == 1 and treeNew[7] == 1):
            prob3 += getJointProbability(treeNew)
        if (treeNew[8] == 1 and treeNew[12] == 1 and treeNew[7] == 1 and treeNew[15] == 0):
            prob4 += getJointProbability(treeNew)
            
        if (treeNew[12] == 1):
            probx12_1 += getJointProbability(treeNew)
        if (treeNew[12] == 1 and treeNew[7] == 1):
            probx12_1_x7_1 += getJointProbability(treeNew)
        if (treeNew[12] == 1 and treeNew[7] == 1 and treeNew[15] == 0):
            probx12_1_x7_1_x15_0 += getJointProbability(treeNew)
        

    
    
    print("p( x8=1 )                      : {}".format(prob1                        ) )
    print("p( x8=1 | x12=1 )              : {}".format(prob2 / probx12_1            ) )
    print("p( x8=1 | x12=1, x7=1 )        : {}".format(prob3 / probx12_1_x7_1       ) )
    print("p( x8=1 | x12=1, x7=1, x15=0 ) : {}".format(prob4 / probx12_1_x7_1_x15_0 ) )


def main():
    '''Execution Begins Here'''
    
    # SMALL TREE
    L = 4             # No of Layers
    n = 2**L - 1      # No of Nodes
    
    startTime = t.time()
    
    print("BRUTE FORCE Small Tree L = {}, n = {} ...".format(L, n))
    configurations = np.asarray(list(it.product([0,1], repeat=n)))
    tree = createTree(n)
    printProbabilities(configurations, tree)
    
    print("Time Required                  : {} secs".format(t.time() - startTime))
    print("Execution Complete!\n")
    
    # LARGE TREE
    L = 6             # No of Layers
    n = 2**L - 1      # No of Nodes
    
    startTime = t.time()
    
    print("BRUTE FORCE Large Tree L = {}, n = {} ...".format(L, n))
    configurations = np.asarray(list(it.product([0,1], repeat=n)))
    tree = createTree(n)
    printProbabilities(configurations, tree)
    
    print("Time Required                  : {} secs".format(t.time() - startTime))
    print("Execution Complete!\n")
  

if __name__ == "__main__" : main()  