'''
Created on Aug 27, 2014

@author: manabchetia

This script implements BRUTE FORCE in a GRID Graph
'''

import itertools as it
import numpy     as np
import time      as t


def createGrid(n):
    '''This function creates a dictionary where keys represent the indices of the nodes in the grid and 
    value represents the values that node can take i.e. o 0 or 1 
    @param n : number of nodes
    @return  : dictionary{node1:valueOf(node1), ..., node2:valueOf(node2)}  
    '''
    grid = {x+1: 0 for x in xrange(n)}
    return grid


def getTransitionProb(i, j, k=None):
    '''This function calculates the transition probabilities
    @param  i: node i
    @param  j: node j
    @parem  k: node k 
    @return  :  transition probability'''
    if(k == None):
        if (i==j):
            return 0.95
        else:
            return 0.05
    else:
        if(i==1 and j==1 and k==1): 
            return 0.99
        if(i==0 and j==1 and k==1): 
            return 0.01
        
        if(i==1 and j==1 and k==0):
            return 0.5
        if(i==0 and j==1 and k==0):
            return 0.5
        
        if(i==1 and j==0 and k==1):
            return 0.5
        if(i==0 and j==0 and k==1):
            return 0.5
        
        if(i==1 and j==0 and k==0):
            return 0.01
        if(i==0 and j==0 and k==0): 
            return 0.99


def assignValuesToGrid(grid, configuration): 
    '''This function assigns each element of a configuration as values to a dictionary where 
    keys represent the index in the tree
    @param  grid          : a dictionary where {node1:0, ..., nodeN:0}
    @param  configuration : one of the several configurations generated by itertools such as [110]
    @return grid          : a dictionary where {node1:valueOf(node1), ..., nodeN:valueOf(node2)}
    '''          
    for i in grid.iterkeys():
        grid[i]=configuration[i-1]
    return grid


def getJointProbability( L, grid ):
    '''This function calculates the joint probability for a particular configuration
    @param grid: a dictionary whose keys are indices of the nodes of a grid and values as values of that node i.e. 0 or 1
    {node1:valueOf(node1), ..., nodeN:valueOf(node2)}
    @return: jointProbability of the input grid
    '''
    jointProbability = 1.0
    for index in grid.iterkeys():
        if   (  index == 1  ):
            jointProbability *= 0.5
        elif ( (index != 1)  and  (  index <= L)  ):
            jointProbability *= getTransitionProb( grid[index], grid[index-1] )
        elif ( (index != 1)  and  ( (index-1)%L == 0 ) ):
            jointProbability *= getTransitionProb( grid[index], grid[index-L] )
        else:
            jointProbability *= getTransitionProb( grid[index], grid[index-1], grid[index-L] )
    return jointProbability     


def getTotalProbability(grid, L, configurations):
    '''NOT REQUIRED
    This function calculates the total Probability as a check that probabilities sum up to 1
    @param grid           :  a dictionary whose keys are indices of the nodes of a tree and values as values of that node i.e. 0 or 1
    {node1:valueOf(node1), ..., nodeN:valueOf(node2)}
    @param L              : number of Layers
    @param configurations :  [[00]
                               [01]
                               [10]
                               [11]]
    @return               : Total Probability
    '''
    totalProbability = 0.0
    for configuration in configurations:
        grid = assignValuesToGrid(grid, configuration)
        jointProbability  = getJointProbability(L, grid)
        totalProbability += jointProbability
        #print(configuration, "  ", jointProbability)
    return totalProbability    

    
def printProbabilitiesSmall(L, configurations, grid):
    '''This function prints out the required probabilities as asked
    @param configurations : array of all possible configurations
    @param grid           : dictionary. E.g. tree = {node1:0, ..., nodeN:0}    
    '''
    prob1 = 0.0
    prob2 = 0.0
    prob3 = 0.0
    prob4 = 0.0
    
    probx16_0             = 0.0
    probx16_0_x1_0       = 0.0
    probx16_0_x1_0_x15_0 = 0.0
    
    for configuration in configurations:
        gridNew = assignValuesToGrid(grid, configuration)
        if (gridNew[6] == 1):
            prob1 += getJointProbability(L, gridNew)
        if (gridNew[6] == 1 and gridNew[16] == 0):
            prob2 += getJointProbability(L, gridNew)
        if (gridNew[6] == 1 and gridNew[16] == 0 and gridNew[1] == 0):
            prob3 += getJointProbability(L, gridNew)
        if (gridNew[6] == 1 and gridNew[16] == 0 and gridNew[1] == 0 and gridNew[15] == 0):
            prob4 += getJointProbability(L, gridNew)
            
        if (gridNew[16] == 0):
            probx16_0 += getJointProbability(L, grid)
        if (gridNew[16] == 0 and gridNew[1] == 0):
            probx16_0_x1_0 += getJointProbability(L, grid)
        if (gridNew[16] == 0 and gridNew[1] == 0 and gridNew[15] == 0):
            probx16_0_x1_0_x15_0 += getJointProbability(L, grid)
    
    
    print("p( x6=1 )                      : {}".format( prob1                        )  )
    print("p( x6=1 | x16=0 )              : {}".format( prob2 / probx16_0            )  )
    print("p( x6=1 | x16=0, x1=0 )        : {}".format( prob3 / probx16_0_x1_0       )  )
    print("p( x6=1 | x16=0, x1=0, x15=0 ) : {}".format( prob4 / probx16_0_x1_0_x15_0 )  )


def printProbabilitiesLarge(L, configurations, grid):
    '''This function prints out the required probabilities as asked
    @param configurations : array of all possible configurations
    @param grid           : dictionary. E.g. tree = {node1:0, ..., nodeN:0}    
    '''
    prob1 = 0.0
    prob2 = 0.0
    prob3 = 0.0
    prob4 = 0.0
    
    probx64_0             = 0.0
    probx64_0_x1_0       = 0.0
    probx57_x64_0 = 0.0
    
    for configuration in configurations:
        gridNew = assignValuesToGrid(grid, configuration)
        if (gridNew[6] == 1):
            prob1 += getJointProbability(L, gridNew)
        if (gridNew[6] == 1 and gridNew[64] == 0):
            prob2 += getJointProbability(L, gridNew)
        if (gridNew[6] == 1 and gridNew[64] == 0 and gridNew[1] == 0):
            prob3 += getJointProbability(L, gridNew)
        if (gridNew[6] == 1 and (gridNew[57]==gridNew[58]==gridNew[59]==gridNew[60]==gridNew[61]==gridNew[62]==gridNew[63]==gridNew[64]==0)):
            prob4 += getJointProbability(L, gridNew)
            
        if (gridNew[64] == 0):
            probx64_0 += getJointProbability(L, grid)
        if (gridNew[64] == 0 and gridNew[1] == 0):
            probx64_0_x1_0 += getJointProbability(L, grid)
        if (gridNew[57]==gridNew[58]==gridNew[59]==gridNew[60]==gridNew[61]==gridNew[62]==gridNew[63]==gridNew[64]==0):
            probx57_x64_0 += getJointProbability(L, grid)
    
    
    print("p( x6=1 )                      : {}".format( prob1                     )  )
    print("p( x6=1 | x64=0 )              : {}".format( prob2 / probx64_0         )  )
    print("p( x6=1 | x64=0, x1=0 )        : {}".format( prob3 / probx64_0_x1_0    )  )
    print("p( x6=1 | x57= ... = x64=0     : {}".format( prob4 / probx57_x64_0     )  )
    
    
def  main():
    '''Execution Begins here'''
    
    # SMALL GRID
    L = 4      # No of Layers
    n = L**2   # No of nodes
    
    print("BRUTE FORCE Small Grid L = {}, n = {}...".format(L, n))
    startTime = t.time()
    
    configurations = np.asarray(  list(  it.product([0,1], repeat=n)  )  )
    grid           = createGrid(n)                                # Create a Grid with L layers
    printProbabilitiesSmall(L, configurations, grid)
    
    print("Time Required                  : {} secs".format(t.time() - startTime))
    print("Execution Complete!\n")
    
    # LARGE GRID
    L = 8      # No of Layers
    n = L**2   # No of nodes
    
    print("BRUTE FORCE Large Grid L = {}, n = {}...".format(L, n))
    startTime = t.time()
    
    configurations = np.asarray(  list(  it.product([0,1], repeat=n)  )  )
    grid           = createGrid(n)                                # Create a Grid with L layers
    printProbabilitiesLarge(L, configurations, grid)
    
    print("Time Required                  : {} secs".format(t.time() - startTime))
    print("Execution Complete!")
    
    
if __name__ == "__main__" : main()  